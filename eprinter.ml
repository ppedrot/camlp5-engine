(* camlp5r *)
(* This file has been generated by program: do not edit! *)
(* Copyright (c) INRIA 2007 *)

type 'a t =
  { mutable pr_fun : string -> 'a pr_fun;
    mutable pr_levels : 'a pr_level list }
and 'a pr_level = { pr_label : string; mutable pr_rules : 'a pr_rule }
and 'a pr_rule =
  ('a, 'a pr_fun -> 'a pr_fun -> (string, string) pr_context -> string)
    Extfun.t
and 'a pr_fun = (string, string) pr_context -> 'a -> string
and ('bef, 'aft) pr_context =
  { ind : int; bef : 'bef; aft : 'aft; dang : string }
;;

type position =
    First
  | Last
  | Before of string
  | After of string
  | Level of string
;;

let add_lev (lab, extf) levs =
  let lab =
    match lab with
      Some lab -> lab
    | None -> ""
  in
  let lev = {pr_label = lab; pr_rules = extf Extfun.empty} in lev :: levs
;;

let extend_printer pr pos levs =
  match pos with
    None ->
      let levels = List.fold_right add_lev levs pr.pr_levels in
      pr.pr_levels <- levels
  | Some (Level lab) ->
      let levels =
        let rec loop =
          function
            pr_lev :: pr_levs ->
              if lab = pr_lev.pr_label then
                match levs with
                  (_, extf) :: levs ->
                    let lev = {pr_lev with pr_rules = extf pr_lev.pr_rules} in
                    let levs = List.fold_right add_lev levs pr_levs in
                    lev :: levs
                | [] -> pr_lev :: pr_levs
              else pr_lev :: loop pr_levs
          | [] -> failwith ("level " ^ lab ^ " not found")
        in
        loop pr.pr_levels
      in
      pr.pr_levels <- levels
  | Some _ -> failwith "not impl EXTEND_PRINTER entry with at level parameter"
;;
