(* camlp5r pa_macro.cmo *)
(* This file has been generated by program: do not edit! *)
(* Copyright (c) INRIA 2007 *)

open Gramext;;

let trace =
  ref (try let _ = Sys.getenv "GRAMTEST" in true with Not_found -> false)
;;

(* *)

(* LR(0) test (experiment) *)

let not_impl name x =
  let desc =
    if Obj.tag (Obj.repr x) = Obj.tag (Obj.repr "") then
      Printf.sprintf "\"%s\"" (Obj.magic x)
    else if Obj.is_block (Obj.repr x) then
      "tag = " ^ string_of_int (Obj.tag (Obj.repr x))
    else "int_val = " ^ string_of_int (Obj.magic x)
  in
  Printf.sprintf "\"gramalgo, not impl: %s; %s\"" name (String.escaped desc)
;;

module Fifo =
  struct
    type 'a t = { mutable bef : 'a list; mutable aft : 'a list };;
    let add x f = {bef = x :: f.bef; aft = f.aft};;
    let get f =
      if f.aft = [] then begin f.aft <- List.rev f.bef; f.bef <- [] end;
      match f.aft with
        x :: aft -> Some (x, {bef = f.bef; aft = aft})
      | [] -> None
    ;;
    let empty () = {bef = []; aft = []};;
    let single x = {bef = []; aft = [x]};;
    let to_list f = List.rev_append f.bef f.aft;;
  end
;;

type ('a, 'b) gram_symb =
    GS_term of 'a
  | GS_nterm of 'b
;;

type action =
    ActShift of int
  | ActReduce of int
  | ActAcc
  | ActErr
;;

let name_of_entry entry levn =
  let lev_name =
    match entry.edesc with
      Dlevels levs ->
        begin match
          (try Some (List.nth levs levn) with Failure _ -> None)
        with
          Some {lname = Some n} ->
            let good_ident_name =
              let rec loop i =
                if i = String.length n then true
                else
                  match n.[i] with
                    'a'..'z' | 'A'..'Z' | '0'..'9' -> loop (i + 1)
                  | _ -> false
              in
              loop 0
            in
            if good_ident_name then n else string_of_int levn
        | Some {lname = None} | None -> string_of_int levn
        end
    | Dparser _ -> string_of_int levn
  in
  entry.ename ^ "-" ^ lev_name
;;

let fold_rules_of_tree f init tree =
  let rec do_tree r accu =
    function
      Node n ->
        let accu = do_tree (n.node :: r) accu n.son in
        do_tree r accu n.brother
    | LocAct (_, _) -> f (List.rev r) accu
    | DeadEnd -> accu
  in
  do_tree [] init tree
;;

let fold_rules_of_level f lev init =
  let accu =
    fold_rules_of_tree f init
      (Node {node = Sself; son = lev.lsuffix; brother = DeadEnd})
  in
  fold_rules_of_tree f accu lev.lprefix
;;

let make_anon_rules anon_rules pref cnt s =
  let rec loop =
    function
      (n, s1) :: rest -> if Gramext.eq_symbol s s1 then n else loop rest
    | [] ->
        incr cnt;
        let n = "x-" ^ pref ^ "-" ^ string_of_int !cnt in
        anon_rules := (n, s) :: !anon_rules; n
  in
  loop !anon_rules
;;

let gram_symb_list cnt to_treat anon_rules self_middle self_end =
  let rec loop =
    function
      [Sself] -> [self_end ()]
    | s :: sl ->
        let s =
          match s with
            Sfacto s -> s
          | Svala (ls, s) -> s
          | s -> s
        in
        let gs =
          match s with
            Snterm e ->
              to_treat := (e, 0) :: !to_treat; GS_nterm (name_of_entry e 0)
          | Snterml (e, lev_name) ->
              let levn =
                match e.edesc with
                  Dlevels levs ->
                    let rec loop n =
                      function
                        lev :: levs ->
                          begin match lev.lname with
                            Some s ->
                              if s = lev_name then n else loop (n + 1) levs
                          | None -> loop (n + 1) levs
                          end
                      | [] -> n
                    in
                    loop 0 levs
                | Dparser _ -> 1
              in
              to_treat := (e, levn) :: !to_treat;
              GS_nterm (name_of_entry e levn)
          | Slist0 _ ->
              let n = make_anon_rules anon_rules "list0" cnt s in GS_nterm n
          | Slist0sep (_, _) ->
              let n = make_anon_rules anon_rules "list0sep" cnt s in
              GS_nterm n
          | Slist1 _ ->
              let n = make_anon_rules anon_rules "list1" cnt s in GS_nterm n
          | Slist1sep (_, _) ->
              let n = make_anon_rules anon_rules "list1sep" cnt s in
              GS_nterm n
          | Sopt _ ->
              let n = make_anon_rules anon_rules "opt" cnt s in GS_nterm n
          | Sflag _ ->
              let n = make_anon_rules anon_rules "flag" cnt s in GS_nterm n
          | Stoken p ->
              let n =
                match p with
                  "", prm -> "\"" ^ prm ^ "\""
                | con, "" -> con
                | con, prm -> "(" ^ con ^ " \"" ^ prm ^ "\")"
              in
              GS_term n
          | Sself -> self_middle ()
          | Stree _ ->
              incr cnt;
              let n = "x-rules-" ^ string_of_int !cnt in
              anon_rules := (n, s) :: !anon_rules; GS_nterm n
          | Svala (ls, s) ->
              incr cnt; let n = "x-v-" ^ string_of_int !cnt in GS_nterm n
          | s -> GS_term (not_impl "gram_symb" s)
        in
        gs :: loop sl
    | [] -> []
  in
  loop
;;

let new_anon_rules cnt to_treat mar ename sy =
  let self () = GS_nterm ename in
  match sy with
    Slist0 s ->
      let sl1 = gram_symb_list cnt to_treat mar self self [s; Sself] in
      let sl2 = [] in [ename, sl1; ename, sl2]
  | Slist0sep (s, sy) ->
      let ename2 = ename ^ "-0" in
      let sl1 = [GS_nterm ename2] in
      let sl2 = [] in
      let self () = GS_nterm ename2 in
      let sl3 = gram_symb_list cnt to_treat mar self self [s; sy; Sself] in
      let sl4 = gram_symb_list cnt to_treat mar self self [s] in
      [ename, sl1; ename, sl2; ename2, sl3; ename2, sl4]
  | Slist1 s ->
      let sl1 = gram_symb_list cnt to_treat mar self self [s; Sself] in
      let sl2 = gram_symb_list cnt to_treat mar self self [s] in
      [ename, sl1; ename, sl2]
  | Slist1sep (s, sy) ->
      let sl1 = gram_symb_list cnt to_treat mar self self [s; sy; Sself] in
      let sl2 = gram_symb_list cnt to_treat mar self self [s] in
      [ename, sl1; ename, sl2]
  | Sopt sy ->
      let sl = gram_symb_list cnt to_treat mar self self [sy] in
      [ename, sl; ename, []]
  | Sflag sy ->
      let sl = gram_symb_list cnt to_treat mar self self [sy] in
      [ename, sl; ename, []]
  | Stree t ->
      let f r rl =
        let sl = gram_symb_list cnt to_treat mar self self r in
        (ename, sl) :: rl
      in
      fold_rules_of_tree f [] t
  | _ -> []
;;

let flatten_gram entry levn =
  let cnt = ref 0 in
  let anon_rules_r = ref [] in
  let treat_level2 rules to_treat entry levn elev lev =
    let to_treat_r = ref to_treat in
    let self_middle () =
      to_treat_r := (entry, 0) :: !to_treat_r;
      GS_nterm (name_of_entry entry 0)
    in
    let self_end () =
      let n =
        match lev.assoc with
          NonA | LeftA -> levn + 1
        | RightA -> levn
      in
      if n <> levn then to_treat_r := (entry, n) :: !to_treat_r;
      GS_nterm (name_of_entry entry n)
    in
    let name = name_of_entry entry levn in
    let f r accu =
      let sl =
        match r with
          Sself :: r ->
            let s =
              let n =
                match lev.assoc with
                  NonA | RightA ->
                    to_treat_r := (entry, levn + 1) :: !to_treat_r; levn + 1
                | LeftA -> levn
              in
              GS_nterm (name_of_entry entry n)
            in
            let sl =
              gram_symb_list cnt to_treat_r anon_rules_r self_middle self_end
                r
            in
            s :: sl
        | r ->
            gram_symb_list cnt to_treat_r anon_rules_r self_middle self_end r
      in
      Fifo.add (name, sl) accu
    in
    let rules = fold_rules_of_level f lev rules in
    let rules =
      match try Some (List.nth elev (levn + 1)) with Failure _ -> None with
        Some _ ->
          let r =
            name_of_entry entry levn,
            [GS_nterm (name_of_entry entry (levn + 1))]
          in
          to_treat_r := (entry, levn + 1) :: !to_treat_r; Fifo.add r rules
      | None -> rules
    in
    rules, !to_treat_r
  in
  let treat_level rules to_treat entry levn elev =
    match try Some (List.nth elev levn) with Failure _ -> None with
      Some lev -> treat_level2 rules to_treat entry levn elev lev
    | None ->
        let rules =
          if levn > 0 then
            (* in initial grammar (grammar.ml), the level after the
               last level is not an error but the last level itself *)
            let ename = name_of_entry entry levn in
            let r = ename, [GS_nterm (name_of_entry entry (levn - 1))] in
            Fifo.add r rules
          else rules
        in
        rules, to_treat
  in
  let treat_entry rules to_treat entry levn =
    match entry.edesc with
      Dlevels [] -> rules, to_treat
    | Dlevels elev -> treat_level rules to_treat entry levn elev
    | Dparser p -> rules, to_treat
  in
  let rec loop rules treated =
    function
      (entry, levn) :: to_treat ->
        if List.mem (entry.ename, levn) treated then
          loop rules treated to_treat
        else
          let treated = (entry.ename, levn) :: treated in
          anon_rules_r := [];
          let (rules, to_treat) = treat_entry rules to_treat entry levn in
          let to_treat_r = ref to_treat in
          let rules =
            let rec loop rules =
              function
                [] -> rules
              | anon_rules ->
                  let more_anon_rules = ref [] in
                  let rules =
                    List.fold_left
                      (fun rules (ename, sy) ->
                         let new_rules =
                           new_anon_rules cnt to_treat_r more_anon_rules ename
                             sy
                         in
                         List.fold_left (fun f r -> Fifo.add r f) rules
                           new_rules)
                      rules (List.rev anon_rules)
                  in
                  loop rules !more_anon_rules
            in
            loop rules !anon_rules_r
          in
          loop rules treated !to_treat_r
    | [] -> Fifo.to_list rules
  in
  loop (Fifo.empty ()) [] [entry, levn]
;;

let sprint_symb term_n nterm_n =
  function
    GS_term s -> term_n s
  | GS_nterm s -> nterm_n s
;;

let eprint_rule term_n nterm_n i (n, sl) =
  Printf.eprintf "%d : %s ->" i (nterm_n n);
  if sl = [] then Printf.eprintf " ε"
  else
    List.iter (fun s -> Printf.eprintf " %s" (sprint_symb term_n nterm_n s))
      sl;
  Printf.eprintf "\n"
;;

let check_closed nterm_n rules =
  let ht = Hashtbl.create 1 in
  Array.iter (fun (e, rh) -> Hashtbl.replace ht e e) rules;
  Array.iteri
    (fun i (e, rh) ->
       List.iter
         (function
            GS_term _ -> ()
          | GS_nterm s ->
              if Hashtbl.mem ht s then ()
              else
                Printf.eprintf "Rule %d: missing non-terminal \"%s\"\n" i
                  (nterm_n s))
         rh)
    rules;
  flush stderr
;;

let get_symbol_after_dot =
  let rec loop dot rh =
    match dot, rh with
      0, s :: _ -> Some s
    | _, [] -> None
    | n, _ :: sl -> loop (n - 1) sl
  in
  loop
;;

let close_item_set rules_of_nterm items =
  let ht = Hashtbl.create 101 in
  let rclos =
    let rec loop rclos =
      function
        (m, added, lh, dot, rh as item) :: rest ->
          if Hashtbl.mem ht (m, dot) then loop rclos rest
          else
            begin
              Hashtbl.add ht (m, dot) ();
              let rest =
                match get_symbol_after_dot dot rh with
                  Some (GS_nterm n) ->
                    let rrest =
                      List.rev_map (fun (i, rh) -> i, true, n, 0, rh)
                        (rules_of_nterm n)
                    in
                    List.rev_append rrest rest
                | Some (GS_term _) | None -> rest
              in
              loop (item :: rclos) rest
            end
      | [] -> rclos
    in
    loop [] items
  in
  List.rev rclos
;;

let eprint_item term_n nterm_n (m, added, lh, dot, rh) =
  if added then Printf.eprintf "+ " else Printf.eprintf "  ";
  Printf.eprintf "%s ->" (nterm_n lh);
  begin let rec loop dot rh =
    if dot = 0 then
      begin
        Printf.eprintf " •";
        List.iter
          (fun s -> Printf.eprintf " %s" (sprint_symb term_n nterm_n s)) rh
      end
    else
      match rh with
        s :: rh ->
          Printf.eprintf " %s" (sprint_symb term_n nterm_n s);
          loop (dot - 1) rh
      | [] -> Printf.eprintf "... algorithm error ..."
  in
    loop dot rh
  end;
  Printf.eprintf "\n"
;;

let make_item_sets rules_of_nterm term_n nterm_n item_set_ht =
  let rec loop ini_item_set_cnt item_set_cnt term_shift nterm_shift
      item_set_ini =
    let item_set =
      List.map (fun (m, _, lh, dot, rh) -> m, false, lh, dot, rh) item_set_ini
    in
    let sl =
      let (rtl, rntl) =
        (* terminals and non-terminals just after the dot *)
        List.fold_left
          (fun (rtl, rntl) (m, added, lh, dot, rh) ->
             match get_symbol_after_dot dot rh with
               Some s ->
                 begin match s with
                   GS_term _ ->
                     (if List.mem s rtl then rtl else s :: rtl), rntl
                 | GS_nterm _ ->
                     rtl, (if List.mem s rntl then rntl else s :: rntl)
                 end
             | None -> rtl, rntl)
          ([], []) item_set
      in
      List.rev_append rtl (List.rev rntl)
    in
    if sl <> [] then
      begin
        Printf.eprintf "\nfrom item_set %d, symbols after dot:"
          ini_item_set_cnt;
        List.iter
          (fun s -> Printf.eprintf " %s" (sprint_symb term_n nterm_n s)) sl;
        Printf.eprintf "\n";
        flush stderr
      end;
    let (item_set_cnt, term_assoc, nterm_assoc, term_shift, nterm_shift) =
      List.fold_left
        (fun (item_set_cnt, term_assoc, nterm_assoc, term_shift, nterm_shift)
             s ->
           let item_set =
             List.find_all
               (fun (m, added, lh, dot, rh) ->
                  match get_symbol_after_dot dot rh with
                    Some s1 -> s = s1
                  | None -> false)
               item_set
           in
           (* move the dot after s *)
           let item_set =
             List.map
               (fun (m, added, lh, dot, rh) -> m, added, lh, dot + 1, rh)
               item_set
           in
           (* complete by closure *)
           let item_set = close_item_set rules_of_nterm item_set in
           Printf.eprintf "\n";
           match
             try Some (Hashtbl.find item_set_ht item_set) with
               Not_found -> None
           with
             Some n ->
               Printf.eprintf "Item set (after %d and %s) = Item set %d\n"
                 ini_item_set_cnt (sprint_symb term_n nterm_n s) n;
               flush stderr;
               let (term_assoc, nterm_assoc) =
                 match s with
                   GS_term s -> (s, n) :: term_assoc, nterm_assoc
                 | GS_nterm s -> term_assoc, (s, n) :: nterm_assoc
               in
               item_set_cnt, term_assoc, nterm_assoc, term_shift, nterm_shift
           | None ->
               Printf.eprintf "Item set %d (after %d and %s)\n\n"
                 (item_set_cnt + 1) ini_item_set_cnt
                 (sprint_symb term_n nterm_n s);
               List.iter (eprint_item term_n nterm_n) item_set;
               flush stderr;
               let item_set_cnt = item_set_cnt + 1 in
               Hashtbl.add item_set_ht item_set item_set_cnt;
               let (term_assoc, nterm_assoc) =
                 let n = item_set_cnt in
                 match s with
                   GS_term s -> (s, n) :: term_assoc, nterm_assoc
                 | GS_nterm s -> term_assoc, (s, n) :: nterm_assoc
               in
               let (item_set_cnt, term_shift, nterm_shift) =
                 loop item_set_cnt item_set_cnt term_shift nterm_shift
                   item_set
               in
               item_set_cnt, term_assoc, nterm_assoc, term_shift, nterm_shift)
        (item_set_cnt, [], [], term_shift, nterm_shift) sl
    in
    let term_shift = (ini_item_set_cnt, term_assoc) :: term_shift in
    let nterm_shift = (ini_item_set_cnt, nterm_assoc) :: nterm_shift in
    item_set_cnt, term_shift, nterm_shift
  in
  loop 0 0 [] []
;;

let make_derive_eps_tab rules nb_nterms =
  let nterm_derive_eps_tab = Array.create nb_nterms false in
  let changes = ref false in
  begin let rec loop () =
    Array.iteri
      (fun i (lh, rh) ->
         let derive_eps =
           List.for_all
             (function
                GS_term _ -> false
              | GS_nterm i -> nterm_derive_eps_tab.(i))
             rh
         in
         if derive_eps then
           if not nterm_derive_eps_tab.(lh) then
             begin nterm_derive_eps_tab.(lh) <- true; changes := true end)
      rules;
    if !changes then begin changes := false; loop () end
  in
    loop ()
  end;
  nterm_derive_eps_tab
;;

let set_first first_tab nterm_derive_eps_tab changes (lh, rh) =
  let rec loop =
    function
      GS_term i :: _ ->
        if not (List.mem i first_tab.(lh)) then
          begin first_tab.(lh) <- i :: first_tab.(lh); changes := true end
    | GS_nterm i :: rest ->
        List.iter
          (fun i ->
             if not (List.mem i first_tab.(lh)) then
               begin
                 first_tab.(lh) <- i :: first_tab.(lh);
                 changes := true
               end)
          first_tab.(i);
        if nterm_derive_eps_tab.(i) then loop rest
    | [] -> ()
  in
  loop rh
;;

let set_follow first_tab follow_tab nterm_derive_eps_tab changes (lh, rh) =
  let rec loop =
    function
      s :: rest ->
        begin match s with
          GS_term _ -> ()
        | GS_nterm i ->
            let rec loop =
              function
                GS_term j :: _ ->
                  if not (List.mem j follow_tab.(i)) then
                    begin
                      follow_tab.(i) <- j :: follow_tab.(i);
                      changes := true
                    end
              | GS_nterm j :: rest ->
                  List.iter
                    (fun k ->
                       if not (List.mem k follow_tab.(i)) then
                         begin
                           follow_tab.(i) <- k :: follow_tab.(i);
                           changes := true
                         end)
                    first_tab.(j);
                  if nterm_derive_eps_tab.(j) then loop rest
              | [] ->
                  List.iter
                    (fun k ->
                       if not (List.mem k follow_tab.(i)) then
                         begin
                           follow_tab.(i) <- k :: follow_tab.(i);
                           changes := true
                         end)
                    follow_tab.(lh)
            in
            loop rest
        end;
        loop rest
    | [] -> ()
  in
  loop rh
;;

let make_first_tab rules nterm_derive_eps_tab =
  let nb_nterms = Array.length nterm_derive_eps_tab in
  let first_tab = Array.create nb_nterms [] in
  let changes = ref false in
  begin let rec loop () =
    Array.iter (set_first first_tab nterm_derive_eps_tab changes) rules;
    if !changes then begin changes := false; loop () end
  in
    loop ()
  end;
  first_tab
;;

let make_follow_tab rules first_tab nterm_derive_eps_tab =
  let nb_terms = Array.length nterm_derive_eps_tab in
  let follow_tab = Array.create nb_terms [] in
  let changes = ref false in
  begin let rec loop () =
    Array.iter (set_follow first_tab follow_tab nterm_derive_eps_tab changes)
      rules;
    if !changes then begin changes := false; loop () end
  in
    loop ()
  end;
  follow_tab
;;

type item = int * bool * int * int * (int, int) gram_symb list;;

type lr0 =
  { rules : (int * (int, int) gram_symb list) array;
    term_name_tab : string array;
    nterm_name_tab : string array;
    item_set_tab : item list array;
    term_shift_tab : (int * int) list array;
    nterm_shift_tab : (int * int) list array }
;;

(*DEFINE TEST1;*)
(*DEFINE TEST2;*)
(*DEFINE TEST3;*)
(* *)

let basic_lr0 entry lev =
  let (rules, term_name_tab, nterm_name_tab) =
    let (rl, entry_name) =
      let rl = flatten_gram entry lev in rl, name_of_entry entry lev
    in
    let rl = ("S", [GS_nterm entry_name; GS_term "$"]) :: rl in
    let term_ht = Hashtbl.create 1 in
    let nterm_ht = Hashtbl.create 1 in
    let (rrl, term_cnt, nterm_cnt) =
      List.fold_left
        (fun (rrl, term_cnt, nterm_cnt) (lh, rh) ->
           let (lh, nterm_cnt) =
             try Hashtbl.find nterm_ht lh, nterm_cnt with
               Not_found ->
                 Hashtbl.add nterm_ht lh nterm_cnt; nterm_cnt, nterm_cnt + 1
           in
           let (rrh, term_cnt, nterm_cnt) =
             List.fold_left
               (fun (rrh, term_cnt, nterm_cnt) s ->
                  let (s, term_cnt, nterm_cnt) =
                    match s with
                      GS_term s ->
                        let (s, term_cnt) =
                          try Hashtbl.find term_ht s, term_cnt with
                            Not_found ->
                              Hashtbl.add term_ht s term_cnt;
                              term_cnt, term_cnt + 1
                        in
                        GS_term s, term_cnt, nterm_cnt
                    | GS_nterm s ->
                        let (s, nterm_cnt) =
                          try Hashtbl.find nterm_ht s, nterm_cnt with
                            Not_found ->
                              Hashtbl.add nterm_ht s nterm_cnt;
                              nterm_cnt, nterm_cnt + 1
                        in
                        GS_nterm s, term_cnt, nterm_cnt
                  in
                  s :: rrh, term_cnt, nterm_cnt)
               ([], term_cnt, nterm_cnt) rh
           in
           (lh, List.rev rrh) :: rrl, term_cnt, nterm_cnt)
        ([], 0, 0) rl
    in
    let term_name_tab =
      let t = Array.create term_cnt "" in
      Hashtbl.iter (fun s i -> t.(i) <- s) term_ht; t
    in
    let nterm_name_tab =
      let t = Array.create nterm_cnt "" in
      Hashtbl.iter (fun s i -> t.(i) <- s) nterm_ht; t
    in
    Array.of_list (List.rev rrl), term_name_tab, nterm_name_tab
  in
  let term_n i = if i = -1 then "ε" else Array.get term_name_tab i in
  let nterm_n = Array.get nterm_name_tab in
  Printf.eprintf "%d rules\n\n" (Array.length rules);
  flush stderr;
  check_closed nterm_n rules;
  Array.iteri (eprint_rule term_n nterm_n) rules;
  Printf.eprintf "\n";
  flush stderr;
  let nb_terms = Array.length term_name_tab in
  let nb_nterms = Array.length nterm_name_tab in
  Printf.eprintf "\n";
  Printf.eprintf "nb of terms %d\n" nb_terms;
  Printf.eprintf "nb of non-terms %d\n" nb_nterms;
  flush stderr;
  let rules_of_nterm_tab = Array.create nb_nterms [] in
  Array.iteri
    (fun i (lh, rh) ->
       rules_of_nterm_tab.(lh) <- (i, rh) :: rules_of_nterm_tab.(lh))
    rules;
  Array.iteri (fun i v -> rules_of_nterm_tab.(i) <- List.rev v)
    rules_of_nterm_tab;
  let rules_of_nterm = Array.get rules_of_nterm_tab in
  let item_set_0 =
    let item = 0, false, fst rules.(0), 0, snd rules.(0) in
    close_item_set rules_of_nterm [item]
  in
  Printf.eprintf "\n";
  Printf.eprintf "Item set 0\n\n";
  List.iter (eprint_item term_n nterm_n) item_set_0;
  flush stderr;
  let item_set_ht = Hashtbl.create 1 in
  let (item_set_cnt, term_assoc, nterm_assoc) =
    make_item_sets rules_of_nterm term_n nterm_n item_set_ht item_set_0
  in
  let item_set_tab = Array.create (item_set_cnt + 1) [] in
  Hashtbl.iter (fun s i -> item_set_tab.(i) <- s) item_set_ht;
  let term_shift_tab = Array.create (item_set_cnt + 1) [] in
  List.iter (fun (i, a) -> term_shift_tab.(i) <- a) term_assoc;
  let nterm_shift_tab = Array.create (item_set_cnt + 1) [] in
  List.iter (fun (i, a) -> nterm_shift_tab.(i) <- a) nterm_assoc;
  Printf.eprintf "\ntotal number of item sets %d\n" (item_set_cnt + 1);
  flush stderr;
  Printf.eprintf "\nshift:\n";
  for i = 0 to item_set_cnt do
    Printf.eprintf "  state %d:" i;
    let symb_shift = term_shift_tab.(i) in
    List.iter (fun (s, i) -> Printf.eprintf " %s->%d" (term_n s) i)
      (List.rev symb_shift);
    let symb_shift = nterm_shift_tab.(i) in
    List.iter (fun (s, i) -> Printf.eprintf " %s->%d" (nterm_n s) i)
      (List.rev symb_shift);
    Printf.eprintf "\n"
  done;
  flush stderr;
  {rules = rules; term_name_tab = term_name_tab;
   nterm_name_tab = nterm_name_tab; item_set_tab = item_set_tab;
   term_shift_tab = term_shift_tab; nterm_shift_tab = nterm_shift_tab}
;;

let make_goto_table blr =
  let nb_item_sets = Array.length blr.item_set_tab in
  let nb_nterms = Array.length blr.nterm_name_tab in
  let goto_table =
    Array.init nb_item_sets (fun _ -> Array.create nb_nterms (-1))
  in
  Array.iteri
    (fun i symb_cnt_assoc ->
       let line = goto_table.(i) in
       List.iter (fun (s, n) -> line.(s) <- n) symb_cnt_assoc)
    blr.nterm_shift_tab;
  goto_table
;;

type algo =
    LR0
  | SLR of int list array
;;

let make_action_table blr algo =
  let nb_terms = Array.length blr.term_name_tab in
  let nb_item_sets = Array.length blr.item_set_tab in
  let term_n i = if i = -1 then "ε" else Array.get blr.term_name_tab i in
  let nterm_n = Array.get blr.nterm_name_tab in
  let compare_terms i j = compare (term_n i) (term_n j) in
  (* column size = number of terminals *)
  let action_table =
    Array.init nb_item_sets (fun _ -> Array.create nb_terms ActErr)
  in
  (* the columns for the terminals are copied to the action table as shift
     actions *)
  Array.iteri
    (fun i symb_cnt_assoc ->
       let line = action_table.(i) in
       List.iter (fun (s, n) -> line.(s) <- ActShift n) symb_cnt_assoc)
    blr.term_shift_tab;
  (* for every item set that contains S → w •, an 'acc' is added in the
     column of the '$' terminal (end of input) *)
  let eoi_pos = 0 in
  (* if an item set i contains an item of the form A → w • and A → w is
     rule m with m > 0 then the row for state i in the action table is
     completely filled with the reduce action rm. *)
  let _nl = ref true in
  Array.iteri
    (fun i item_set ->
       List.iter
         (fun (m, _, _, dot, rh) ->
            if m = 0 then
              (if dot = List.length rh then
                 action_table.(i).(eoi_pos) <- ActAcc)
            else if dot = List.length rh then
              let line = action_table.(i) in
              for j = 0 to Array.length line - 1 do
                let do_it =
                  match algo with
                    LR0 -> true
                  | SLR follow_tab ->
                      let i = fst blr.rules.(m) in List.mem j follow_tab.(i)
                in
                if do_it then
                  match line.(j) with
                    ActShift n ->
                      if !_nl then Printf.eprintf "\n";
                      _nl := false;
                      Printf.eprintf "State %d: conflict shift/reduce" i;
                      Printf.eprintf " shift %d rule %d\n" n m;
                      Printf.eprintf "  shift with terminal %s\n" (term_n j);
                      Printf.eprintf "  reduce with rule ";
                      eprint_rule term_n nterm_n m blr.rules.(m);
                      begin match algo with
                        LR0 -> ()
                      | SLR follow_tab ->
                          let i = fst blr.rules.(m) in
                          Printf.eprintf "  follow (%s) =" (nterm_n i);
                          List.iter (fun s -> Printf.eprintf " %s" (term_n s))
                            (List.sort compare_terms follow_tab.(i));
                          Printf.eprintf "\n"
                      end;
                      flush stderr
                  | ActReduce m1 ->
                      begin match algo with
                        LR0 ->
                          if j = 0 then
                            begin
                              if !_nl then Printf.eprintf "\n";
                              _nl := false;
                              Printf.eprintf "State %d:" i;
                              Printf.eprintf " conflict reduce/reduce";
                              Printf.eprintf " rules %d and %d\n" m1 m;
                              Printf.eprintf "  reduce with rule ";
                              eprint_rule term_n nterm_n m1 blr.rules.(m1);
                              Printf.eprintf "  reduce with rule ";
                              eprint_rule term_n nterm_n m blr.rules.(m);
                              flush stderr
                            end
                      | SLR follow_tab ->
                          if !_nl then Printf.eprintf "\n";
                          _nl := false;
                          Printf.eprintf "State %d, terminal %s" i (term_n j);
                          Printf.eprintf ": conflict reduce/reduce";
                          Printf.eprintf " rules %d and %d\n" m1 m;
                          Printf.eprintf "  reduce with rule ";
                          eprint_rule term_n nterm_n m1 blr.rules.(m1);
                          Printf.eprintf "  reduce with rule ";
                          eprint_rule term_n nterm_n m blr.rules.(m);
                          let i1 = fst blr.rules.(m1) in
                          let i2 = fst blr.rules.(m) in
                          let follow_m1 = follow_tab.(i1) in
                          let follow_m = follow_tab.(i2) in
                          Printf.eprintf "  follow (%s) =" (nterm_n i1);
                          List.iter (fun s -> Printf.eprintf " %s" (term_n s))
                            (List.sort compare_terms follow_m1);
                          Printf.eprintf "\n";
                          Printf.eprintf "  follow (%s) =" (nterm_n i2);
                          List.iter (fun s -> Printf.eprintf " %s" (term_n s))
                            (List.sort compare_terms follow_m);
                          Printf.eprintf "\n";
                          flush stderr
                      end
                  | _ -> line.(j) <- ActReduce m
              done)
         item_set)
    blr.item_set_tab;
  action_table
;;

let trace_goto_table blr goto_table =
  Printf.eprintf "\ngoto table\n\n";
  if Array.length goto_table > 20 then Printf.eprintf "  (big)\n"
  else
    begin
      Printf.eprintf "           ";
      for i = 0 to Array.length blr.nterm_name_tab - 1 do
        Printf.eprintf " %s" blr.nterm_name_tab.(i)
      done;
      Printf.eprintf "\n";
      for i = 0 to Array.length goto_table - 1 do
        Printf.eprintf "  state %d :" i;
        let line = goto_table.(i) in
        for j = 0 to Array.length line - 1 do
          if line.(j) = -1 then Printf.eprintf " -"
          else Printf.eprintf " %d" line.(j)
        done;
        Printf.eprintf "\n"
      done
    end;
  flush stderr
;;

let trace_action_table blr action_table =
  Printf.eprintf "\naction table\n\n";
  if Array.length action_table > 20 then Printf.eprintf "  (big)\n"
  else
    begin
      Printf.eprintf "           ";
      for i = 0 to Array.length blr.term_name_tab - 1 do
        Printf.eprintf " %4s" blr.term_name_tab.(i)
      done;
      Printf.eprintf "\n";
      for i = 0 to Array.length action_table - 1 do
        Printf.eprintf "  state %d :" i;
        let line = action_table.(i) in
        for j = 0 to Array.length line - 1 do
          match line.(j) with
            ActShift n -> Printf.eprintf " %4s" (Printf.sprintf "s%d" n)
          | ActReduce n -> Printf.eprintf " %4s" (Printf.sprintf "r%d" n)
          | ActAcc -> Printf.eprintf "   acc"
          | ActErr -> Printf.eprintf "    -"
        done;
        Printf.eprintf "\n"
      done
    end;
  flush stderr
;;

let trace_nterm_derive_eps_tab blr nterm_derive_eps_tab =
  let nterm_n = Array.get blr.nterm_name_tab in
  Printf.eprintf "\nDerive ε\n\n";
  Printf.eprintf " ";
  Array.iteri
    (fun i derive_eps -> if derive_eps then Printf.eprintf " %s" (nterm_n i))
    nterm_derive_eps_tab;
  flush stderr
;;

let trace_first_tab blr first_tab =
  let term_n i = if i = -1 then "ε" else Array.get blr.term_name_tab i in
  let compare_terms i j = compare (term_n i) (term_n j) in
  Printf.eprintf "\nFirst\n\n";
  Array.iteri
    (fun i s ->
       Printf.eprintf "  first (%s) =" s;
       List.iter (fun s -> Printf.eprintf " %s" (term_n s))
         (List.sort compare_terms first_tab.(i));
       Printf.eprintf "\n")
    blr.nterm_name_tab;
  flush stderr
;;

let trace_follow_tab blr follow_tab =
  let term_n i = if i = -1 then "ε" else Array.get blr.term_name_tab i in
  let compare_terms i j = compare (term_n i) (term_n j) in
  Printf.eprintf "\nFollow\n\n";
  Array.iteri
    (fun i s ->
       Printf.eprintf "  follow (%s) =" s;
       List.iter (fun s -> Printf.eprintf " %s" (term_n s))
         (List.sort compare_terms follow_tab.(i));
       Printf.eprintf "\n")
    blr.nterm_name_tab;
  flush stderr
;;

let lr0 entry lev =
  Printf.eprintf "LR(0) %s %d\n" entry.ename lev;
  flush stderr;
  let blr = basic_lr0 entry lev in
  let goto_table = make_goto_table blr in
  trace_goto_table blr goto_table;
  let action_table = make_action_table blr LR0 in
  trace_action_table blr action_table
;;

let slr entry lev =
  Printf.eprintf "SLR %s %d\n" entry.ename lev;
  flush stderr;
  let blr = basic_lr0 entry lev in
  let nb_nterms = Array.length blr.nterm_name_tab in
  let nterm_derive_eps_tab = make_derive_eps_tab blr.rules nb_nterms in
  trace_nterm_derive_eps_tab blr nterm_derive_eps_tab;
  let first_tab = make_first_tab blr.rules nterm_derive_eps_tab in
  trace_first_tab blr first_tab;
  let follow_tab = make_follow_tab blr.rules first_tab nterm_derive_eps_tab in
  trace_follow_tab blr follow_tab;
  let goto_table = make_goto_table blr in
  trace_goto_table blr goto_table;
  let action_table = make_action_table blr (SLR follow_tab) in
  trace_action_table blr action_table
;;

let f entry lev =
  match Sys.getenv "GRAMTEST" with
    "LR0" -> lr0 entry lev
  | "SLR" -> slr entry lev
  | _ -> ()
;;
