(* camlp4r *)
(***********************************************************************)
(*                                                                     *)
(*                             Camlp4                                  *)
(*                                                                     *)
(*                Daniel de Rauglaudre, INRIA Rocquencourt             *)
(*                                                                     *)
(*  Copyright 2007 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

(* This file has been generated by program: do not edit! *)

open Stdpp;;
open Token;;

let no_quotations = ref false;;

(* The string buffering machinery *)

module B :
  sig
    type t;;
    val empty : t;;
    val char : char -> t;;
    val string : string -> t;;
    val is_empty : t -> bool;;
    val add : t -> char -> t;;
    val add_str : t -> string -> t;;
    val get : t -> string;;
  end =
  struct
    type t = char list;;
    let empty = [];;
    let is_empty l = l = [];;
    let add l c = c :: l;;
    let add_str l s =
      let rec loop l i =
        if i = String.length s then l
        else loop (String.unsafe_get s i :: l) (i + 1)
      in
      loop l 0
    ;;
    let char c = [c];;
    let string = add_str [];;
    let get l =
      let s = String.create (List.length l) in
      let rec loop i =
        function
          c :: l -> String.unsafe_set s i c; loop (i - 1) l
        | [] -> s
      in
      loop (String.length s - 1) l
    ;;
  end
;;

(* The lexer *)

let stream_peek_nth n strm =
  let rec loop n =
    function
      [] -> None
    | [x] -> if n == 1 then Some x else None
    | _ :: l -> loop (n - 1) l
  in
  loop n (Stream.npeek n strm)
;;

let p_opt f buf (strm__ : _ Stream.t) =
  match
    try Some (f buf strm__) with
      Stream.Failure -> None
  with
    Some c -> buf
  | _ -> buf
;;

let rec decimal_digits_under buf (strm__ : _ Stream.t) =
  match Stream.peek strm__ with
    Some ('0'..'9' | '_' as c) ->
      Stream.junk strm__; decimal_digits_under (B.add buf c) strm__
  | _ -> buf
;;

let rec ident buf (strm__ : _ Stream.t) =
  match Stream.peek strm__ with
    Some
      ('A'..'Z' | 'a'..'z' | '\192'..'\214' | '\216'..'\246' |
       '\248'..'\255' | '0'..'9' | '_' | '\'' as c) ->
      Stream.junk strm__; ident (B.add buf c) strm__
  | _ -> buf
and ident2 buf (strm__ : _ Stream.t) =
  match Stream.peek strm__ with
    Some
      ('!' | '?' | '~' | '=' | '@' | '^' | '&' | '+' | '-' | '*' | '/' | '%' |
       '.' | ':' | '<' | '>' | '|' | '$' as c) ->
      Stream.junk strm__; ident2 (B.add buf c) strm__
  | _ -> buf
and ident3 buf (strm__ : _ Stream.t) =
  match Stream.peek strm__ with
    Some
      ('0'..'9' | 'A'..'Z' | 'a'..'z' | '\192'..'\214' | '\216'..'\246' |
       '\248'..'\255' | '_' | '!' | '%' | '&' | '*' | '+' | '-' | '.' | '/' |
       ':' | '<' | '=' | '>' | '?' | '@' | '^' | '|' | '~' | '\'' | '$' as c
         ) ->
      Stream.junk strm__; ident3 (B.add buf c) strm__
  | _ -> buf
and digits kind buf (strm__ : _ Stream.t) =
  let d =
    try kind strm__ with
      Stream.Failure -> raise (Stream.Error "ill-formed integer constant")
  in
  digits_under kind (B.add buf d) strm__
and digits_under kind buf (strm__ : _ Stream.t) =
  match
    try Some (kind strm__) with
      Stream.Failure -> None
  with
    Some d -> digits_under kind (B.add buf d) strm__
  | _ ->
      match Stream.peek strm__ with
        Some '_' -> Stream.junk strm__; digits_under kind buf strm__
      | Some 'l' -> Stream.junk strm__; "INT_l", B.get buf
      | Some 'L' -> Stream.junk strm__; "INT_L", B.get buf
      | Some 'n' -> Stream.junk strm__; "INT_n", B.get buf
      | _ -> "INT", B.get buf
and octal (strm__ : _ Stream.t) =
  match Stream.peek strm__ with
    Some ('0'..'7' as d) -> Stream.junk strm__; d
  | _ -> raise Stream.Failure
and hexa (strm__ : _ Stream.t) =
  match Stream.peek strm__ with
    Some ('0'..'9' | 'a'..'f' | 'A'..'F' as d) -> Stream.junk strm__; d
  | _ -> raise Stream.Failure
and binary (strm__ : _ Stream.t) =
  match Stream.peek strm__ with
    Some ('0'..'1' as d) -> Stream.junk strm__; d
  | _ -> raise Stream.Failure
;;

let exponent_part buf (strm__ : _ Stream.t) =
  match Stream.peek strm__ with
    Some ('e' | 'E' as c) ->
      Stream.junk strm__;
      let buf =
        p_opt
          (fun buf (strm__ : _ Stream.t) ->
             match Stream.peek strm__ with
               Some ('+' | '-' as c) -> Stream.junk strm__; B.add buf c
             | _ -> raise Stream.Failure)
          (B.add buf c) strm__
      in
      begin try
        match Stream.peek strm__ with
          Some ('0'..'9' as c) ->
            Stream.junk strm__; decimal_digits_under (B.add buf c) strm__
        | _ -> raise Stream.Failure
      with
        Stream.Failure ->
          raise (Stream.Error "ill-formed floating-point constant")
      end
  | _ -> raise Stream.Failure
;;

let number buf (strm__ : _ Stream.t) =
  let buf = decimal_digits_under buf strm__ in
  match Stream.peek strm__ with
    Some '.' ->
      Stream.junk strm__;
      let buf = decimal_digits_under (B.add buf '.') strm__ in
      let buf = p_opt exponent_part buf strm__ in "FLOAT", B.get buf
  | _ ->
      match
        try Some (exponent_part buf strm__) with
          Stream.Failure -> None
      with
        Some buf -> "FLOAT", B.get buf
      | _ ->
          match Stream.peek strm__ with
            Some 'l' -> Stream.junk strm__; "INT_l", B.get buf
          | Some 'L' -> Stream.junk strm__; "INT_L", B.get buf
          | Some 'n' -> Stream.junk strm__; "INT_n", B.get buf
          | _ -> "INT", B.get buf
;;

let error_on_unknown_keywords = ref false;;

let bol_pos = Token.bol_pos;;
let line_nb = Token.line_nb;;

let next_token_fun dfa ssd find_kwd glexr =
  let t_line_nb = ref 0 in
  let t_bol_pos = ref 0 in
  let err loc msg =
    Stdpp.raise_with_loc (Stdpp.make_lined_loc !t_line_nb !t_bol_pos loc)
      (Token.Error msg)
  in
  let keyword_or_error loc s =
    try "", find_kwd s with
      Not_found ->
        if !error_on_unknown_keywords then err loc ("illegal token: " ^ s)
        else "", s
  in
  let line_cnt bp1 c =
    match c with
      '\n' | '\r' -> incr !line_nb; !bol_pos := bp1 + 1; c
    | c -> c
  in
  let rec next_token after_space strm =
    t_line_nb := !(!line_nb);
    t_bol_pos := !(!bol_pos);
    let (strm__ : _ Stream.t) = strm in
    let bp = Stream.count strm__ in
    match Stream.peek strm__ with
      Some ('\n' | '\r') ->
        Stream.junk strm__;
        let s = strm__ in
        let ep = Stream.count strm__ in
        !bol_pos := ep; incr !line_nb; next_token true s
    | Some (' ' | '\t' | '\026' | '\012') ->
        Stream.junk strm__; next_token true strm__
    | Some '#' when bp = !(!bol_pos) ->
        Stream.junk strm__;
        let s = strm__ in
        if linedir 1 s then begin any_to_nl s; next_token true s end
        else
          let loc = bp, bp + 1 in
          (keyword_or_error loc "#", loc), !t_line_nb, !t_bol_pos
    | Some '(' ->
        Stream.junk strm__;
        begin match Stream.peek strm__ with
          Some '*' ->
            Stream.junk strm__;
            let _ = comment bp strm__ in next_token true strm__
        | _ ->
            let ep = Stream.count strm__ in
            let loc = bp, ep in
            (keyword_or_error (bp, ep) "(", loc), !(!line_nb), !(!bol_pos)
        end
    | _ ->
        let tok = next_token_kont after_space strm__ in
        let ep = Stream.count strm__ in
        (tok, (bp, max (bp + 1) ep)), !t_line_nb, !t_bol_pos
  and next_token_kont after_space (strm__ : _ Stream.t) =
    let bp = Stream.count strm__ in
    match Stream.peek strm__ with
      Some ('A'..'Z' | '\192'..'\214' | '\216'..'\222' as c) ->
        Stream.junk strm__;
        let buf = ident (B.char c) strm__ in
        let id = B.get buf in
        begin try "", find_kwd id with
          Not_found -> "UIDENT", id
        end
    | Some ('a'..'z' | '\223'..'\246' | '\248'..'\255' | '_' as c) ->
        Stream.junk strm__;
        let buf = ident (B.char c) strm__ in
        let id = B.get buf in
        begin try "", find_kwd id with
          Not_found -> "LIDENT", id
        end
    | Some ('1'..'9' as c) -> Stream.junk strm__; number (B.char c) strm__
    | Some '0' ->
        Stream.junk strm__;
        begin match Stream.peek strm__ with
          Some ('o' | 'O') ->
            Stream.junk strm__; digits octal (B.string "0o") strm__
        | Some ('x' | 'X') ->
            Stream.junk strm__; digits hexa (B.string "0x") strm__
        | Some ('b' | 'B') ->
            Stream.junk strm__; digits binary (B.string "0b") strm__
        | _ -> number (B.char '0') strm__
        end
    | Some '\'' ->
        Stream.junk strm__;
        let s = strm__ in
        let ep = Stream.count strm__ in
        begin match Stream.npeek 2 s with
          [_; '\''] | ['\\'; _] -> "CHAR", B.get (char bp B.empty s)
        | _ -> keyword_or_error (bp, ep) "'"
        end
    | Some '\"' ->
        Stream.junk strm__;
        let buf = string bp B.empty strm__ in "STRING", B.get buf
    | Some '$' -> Stream.junk strm__; dollar bp B.empty strm__
    | Some ('!' | '=' | '@' | '^' | '&' | '+' | '-' | '*' | '/' | '%' as c) ->
        Stream.junk strm__;
        let buf = ident2 (B.char c) strm__ in
        let ep = Stream.count strm__ in keyword_or_error (bp, ep) (B.get buf)
    | Some ('~' as c) ->
        Stream.junk strm__;
        begin match Stream.peek strm__ with
          Some ('a'..'z' as c) ->
            Stream.junk strm__;
            let buf = ident (B.char c) strm__ in "TILDEIDENT", B.get buf
        | _ ->
            let buf = ident2 (B.char c) strm__ in
            let ep = Stream.count strm__ in
            keyword_or_error (bp, ep) (B.get buf)
        end
    | Some ('?' as c) ->
        Stream.junk strm__;
        begin match Stream.peek strm__ with
          Some ('a'..'z' as c) ->
            Stream.junk strm__;
            let buf = ident (B.char c) strm__ in "QUESTIONIDENT", B.get buf
        | _ ->
            let buf = ident2 (B.char c) strm__ in
            let ep = Stream.count strm__ in
            keyword_or_error (bp, ep) (B.get buf)
        end
    | Some '<' -> Stream.junk strm__; less bp strm__
    | Some (':' as c1) ->
        Stream.junk strm__;
        let buf =
          match Stream.peek strm__ with
            Some (']' | ':' | '=' | '>' as c2) ->
              Stream.junk strm__; B.add (B.char c1) c2
          | _ -> B.char c1
        in
        let ep = Stream.count strm__ in keyword_or_error (bp, ep) (B.get buf)
    | Some ('>' | '|' as c1) ->
        Stream.junk strm__;
        let buf =
          match Stream.peek strm__ with
            Some (']' | '}' as c2) -> Stream.junk strm__; B.add (B.char c1) c2
          | _ -> ident2 (B.char c1) strm__
        in
        let ep = Stream.count strm__ in keyword_or_error (bp, ep) (B.get buf)
    | Some ('[' | '{' as c1) ->
        Stream.junk strm__;
        let s = strm__ in
        let buf =
          match Stream.npeek 2 s with
            ['<'; '<' | ':'] -> B.char c1
          | _ ->
              let (strm__ : _ Stream.t) = s in
              match Stream.peek strm__ with
                Some ('|' | '<' | ':' as c2) ->
                  Stream.junk strm__; B.add (B.char c1) c2
              | _ -> B.char c1
        in
        keyword_or_error (bp, Stream.count s) (B.get buf)
    | Some '.' ->
        Stream.junk strm__;
        let id =
          match Stream.peek strm__ with
            Some '.' -> Stream.junk strm__; ".."
          | _ -> if ssd && after_space then " ." else "."
        in
        let ep = Stream.count strm__ in keyword_or_error (bp, ep) id
    | Some ';' ->
        Stream.junk strm__;
        let id =
          match Stream.peek strm__ with
            Some ';' -> Stream.junk strm__; ";;"
          | _ -> ";"
        in
        let ep = Stream.count strm__ in keyword_or_error (bp, ep) id
    | Some '\\' ->
        Stream.junk strm__;
        let buf = ident3 B.empty strm__ in "LIDENT", B.get buf
    | Some c ->
        Stream.junk strm__;
        let ep = Stream.count strm__ in
        keyword_or_error (bp, ep) (String.make 1 c)
    | _ -> let _ = Stream.empty strm__ in "EOI", ""
  and less bp strm =
    if !no_quotations then
      let (strm__ : _ Stream.t) = strm in
      let buf = ident2 (B.char '<') strm__ in
      let ep = Stream.count strm__ in keyword_or_error (bp, ep) (B.get buf)
    else
      let (strm__ : _ Stream.t) = strm in
      match Stream.peek strm__ with
        Some '<' ->
          Stream.junk strm__;
          let buf =
            try quotation bp B.empty strm__ with
              Stream.Failure -> raise (Stream.Error "")
          in
          "QUOTATION", ":" ^ B.get buf
      | Some ':' ->
          Stream.junk strm__;
          let i =
            try let buf = ident B.empty strm__ in B.get buf with
              Stream.Failure -> raise (Stream.Error "")
          in
          begin match Stream.peek strm__ with
            Some '<' ->
              Stream.junk strm__;
              let buf =
                try quotation bp B.empty strm__ with
                  Stream.Failure -> raise (Stream.Error "")
              in
              "QUOTATION", i ^ ":" ^ B.get buf
          | _ -> raise (Stream.Error "character '<' expected")
          end
      | _ ->
          let buf = ident2 (B.char '<') strm__ in
          let ep = Stream.count strm__ in
          keyword_or_error (bp, ep) (B.get buf)
  and string bp buf (strm__ : _ Stream.t) =
    let bp1 = Stream.count strm__ in
    match Stream.peek strm__ with
      Some '\"' -> Stream.junk strm__; buf
    | Some '\\' ->
        Stream.junk strm__;
        begin match Stream.peek strm__ with
          Some c ->
            Stream.junk strm__;
            string bp (B.add (B.add buf '\\') (line_cnt (bp1 + 1) c)) strm__
        | _ -> raise (Stream.Error "")
        end
    | Some c ->
        Stream.junk strm__; string bp (B.add buf (line_cnt bp1 c)) strm__
    | _ ->
        let ep = Stream.count strm__ in err (bp, ep) "string not terminated"
  and char bp buf (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some '\'' ->
        Stream.junk strm__;
        let s = strm__ in
        if B.is_empty buf then char bp (B.add buf '\'') s else buf
    | Some '\\' ->
        Stream.junk strm__;
        begin match Stream.peek strm__ with
          Some c ->
            Stream.junk strm__; char bp (B.add (B.add buf '\\') c) strm__
        | _ -> raise (Stream.Error "")
        end
    | Some c -> Stream.junk strm__; char bp (B.add buf c) strm__
    | _ -> let ep = Stream.count strm__ in err (bp, ep) "char not terminated"
  and dollar bp buf (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some '$' -> Stream.junk strm__; "ANTIQUOT", ":" ^ B.get buf
    | Some ('a'..'z' | 'A'..'Z' as c) ->
        Stream.junk strm__; antiquot bp (B.add buf c) strm__
    | Some ('0'..'9' as c) ->
        Stream.junk strm__; maybe_locate bp (B.add buf c) strm__
    | Some ':' ->
        Stream.junk strm__;
        let k = B.get buf in
        "ANTIQUOT", k ^ ":" ^ locate_or_antiquot_rest bp B.empty strm__
    | Some '\\' ->
        Stream.junk strm__;
        begin match Stream.peek strm__ with
          Some c ->
            Stream.junk strm__;
            "ANTIQUOT", ":" ^ locate_or_antiquot_rest bp (B.add buf c) strm__
        | _ -> raise (Stream.Error "")
        end
    | _ ->
        let s = strm__ in
        if dfa then
          let (strm__ : _ Stream.t) = s in
          match Stream.peek strm__ with
            Some c ->
              Stream.junk strm__;
              "ANTIQUOT", ":" ^ locate_or_antiquot_rest bp (B.add buf c) s
          | _ ->
              let ep = Stream.count strm__ in
              err (bp, ep) "antiquotation not terminated"
        else "", B.get (ident2 (B.char '$') s)
  and maybe_locate bp buf (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some '$' -> Stream.junk strm__; "ANTIQUOT", ":" ^ B.get buf
    | Some ('0'..'9' as c) ->
        Stream.junk strm__; maybe_locate bp (B.add buf c) strm__
    | Some ':' ->
        Stream.junk strm__;
        "LOCATE", B.get buf ^ ":" ^ locate_or_antiquot_rest bp B.empty strm__
    | Some '\\' ->
        Stream.junk strm__;
        begin match Stream.peek strm__ with
          Some c ->
            Stream.junk strm__;
            "ANTIQUOT", ":" ^ locate_or_antiquot_rest bp (B.add buf c) strm__
        | _ -> raise (Stream.Error "")
        end
    | Some c ->
        Stream.junk strm__;
        "ANTIQUOT", ":" ^ locate_or_antiquot_rest bp (B.add buf c) strm__
    | _ ->
        let ep = Stream.count strm__ in
        err (bp, ep) "antiquotation not terminated"
  and antiquot bp buf (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some '$' -> Stream.junk strm__; "ANTIQUOT", ":" ^ B.get buf
    | Some ('a'..'z' | 'A'..'Z' | '0'..'9' as c) ->
        Stream.junk strm__; antiquot bp (B.add buf c) strm__
    | Some ':' ->
        Stream.junk strm__;
        let k = B.get buf in
        "ANTIQUOT", k ^ ":" ^ locate_or_antiquot_rest bp B.empty strm__
    | Some '\\' ->
        Stream.junk strm__;
        begin match Stream.peek strm__ with
          Some c ->
            Stream.junk strm__;
            "ANTIQUOT", ":" ^ locate_or_antiquot_rest bp (B.add buf c) strm__
        | _ -> raise (Stream.Error "")
        end
    | Some c ->
        Stream.junk strm__;
        "ANTIQUOT", ":" ^ locate_or_antiquot_rest bp (B.add buf c) strm__
    | _ ->
        let ep = Stream.count strm__ in
        err (bp, ep) "antiquotation not terminated"
  and locate_or_antiquot_rest bp buf (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some '$' -> Stream.junk strm__; B.get buf
    | Some '\\' ->
        Stream.junk strm__;
        begin match Stream.peek strm__ with
          Some c ->
            Stream.junk strm__;
            locate_or_antiquot_rest bp (B.add buf c) strm__
        | _ -> raise (Stream.Error "")
        end
    | Some c ->
        Stream.junk strm__; locate_or_antiquot_rest bp (B.add buf c) strm__
    | _ ->
        let ep = Stream.count strm__ in
        err (bp, ep) "antiquotation not terminated"
  and quotation bp buf (strm__ : _ Stream.t) =
    let bp1 = Stream.count strm__ in
    match Stream.peek strm__ with
      Some '>' -> Stream.junk strm__; maybe_end_quotation bp buf strm__
    | Some '<' ->
        Stream.junk strm__;
        let buf = maybe_nested_quotation bp (B.add buf '<') strm__ in
        quotation bp buf strm__
    | Some '\\' ->
        Stream.junk strm__;
        let buf =
          match Stream.peek strm__ with
            Some ('>' | '<' | '\\' as c) -> Stream.junk strm__; B.add buf c
          | _ -> B.add buf '\\'
        in
        quotation bp buf strm__
    | Some c ->
        Stream.junk strm__; quotation bp (B.add buf (line_cnt bp1 c)) strm__
    | _ ->
        let ep = Stream.count strm__ in
        err (bp, ep) "quotation not terminated"
  and maybe_nested_quotation bp buf (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some '<' ->
        Stream.junk strm__;
        let buf = quotation bp (B.add buf '<') strm__ in B.add_str buf ">>"
    | Some ':' ->
        Stream.junk strm__;
        let buf = ident (B.add buf ':') strm__ in
        begin try
          match Stream.peek strm__ with
            Some '<' ->
              Stream.junk strm__;
              let buf = quotation bp (B.add buf '<') strm__ in
              B.add_str buf ">>"
          | _ -> buf
        with
          Stream.Failure -> raise (Stream.Error "")
        end
    | _ -> buf
  and maybe_end_quotation bp buf (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some '>' -> Stream.junk strm__; buf
    | _ -> quotation bp (B.add buf '>') strm__
  and comment bp (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some '(' -> Stream.junk strm__; left_paren_in_comment bp strm__
    | Some '*' -> Stream.junk strm__; star_in_comment bp strm__
    | Some '\"' ->
        Stream.junk strm__;
        let _ =
          try string bp B.empty strm__ with
            Stream.Failure -> raise (Stream.Error "")
        in
        comment bp strm__
    | Some '\'' -> Stream.junk strm__; quote_in_comment bp strm__
    | Some ('\n' | '\r') ->
        Stream.junk strm__; let s = strm__ in incr !line_nb; comment bp s
    | Some c -> Stream.junk strm__; comment bp strm__
    | _ ->
        let ep = Stream.count strm__ in err (bp, ep) "comment not terminated"
  and quote_in_comment bp (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some '\'' -> Stream.junk strm__; comment bp strm__
    | Some '\\' -> Stream.junk strm__; quote_antislash_in_comment bp 0 strm__
    | _ ->
        let s = strm__ in
        begin match Stream.npeek 2 s with
          [_; '\''] -> Stream.junk s; Stream.junk s
        | _ -> ()
        end;
        comment bp s
  and quote_any_in_comment bp (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some '\'' -> Stream.junk strm__; comment bp strm__
    | _ -> comment bp strm__
  and quote_antislash_in_comment bp buf (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some '\'' -> Stream.junk strm__; comment bp strm__
    | Some ('\\' | '\"' | 'n' | 't' | 'b' | 'r') ->
        Stream.junk strm__; quote_any_in_comment bp strm__
    | Some ('0'..'9') ->
        Stream.junk strm__; quote_antislash_digit_in_comment bp strm__
    | _ -> comment bp strm__
  and quote_antislash_digit_in_comment bp (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some ('0'..'9') ->
        Stream.junk strm__; quote_antislash_digit2_in_comment bp strm__
    | _ -> comment bp strm__
  and quote_antislash_digit2_in_comment bp (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some ('0'..'9') -> Stream.junk strm__; quote_any_in_comment bp strm__
    | _ -> comment bp strm__
  and left_paren_in_comment bp (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some '*' ->
        Stream.junk strm__; let _ = comment bp strm__ in comment bp strm__
    | _ -> comment bp strm__
  and star_in_comment bp (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some ')' -> Stream.junk strm__; ()
    | _ -> comment bp strm__
  and linedir n s =
    match stream_peek_nth n s with
      Some (' ' | '\t') -> linedir (n + 1) s
    | Some ('0'..'9') -> linedir_digits (n + 1) s
    | _ -> false
  and linedir_digits n s =
    match stream_peek_nth n s with
      Some ('0'..'9') -> linedir_digits (n + 1) s
    | _ -> linedir_quote n s
  and linedir_quote n s =
    match stream_peek_nth n s with
      Some (' ' | '\t') -> linedir_quote (n + 1) s
    | Some '\"' -> true
    | _ -> false
  and any_to_nl (strm__ : _ Stream.t) =
    match Stream.peek strm__ with
      Some ('\r' | '\n') ->
        Stream.junk strm__; let ep = Stream.count strm__ in !bol_pos := ep
    | Some _ -> Stream.junk strm__; any_to_nl strm__
    | _ -> ()
  in
  fun (cstrm, s_line_nb, s_bol_pos) ->
    try
      begin match !(Token.restore_lexing_info) with
        Some (line_nb, bol_pos) ->
          s_line_nb := line_nb;
          s_bol_pos := bol_pos;
          Token.restore_lexing_info := None
      | None -> ()
      end;
      line_nb := s_line_nb;
      bol_pos := s_bol_pos;
      let glex = !glexr in
      let comm_bp = Stream.count cstrm in
      let ((r, loc), t_line_nb, t_bol_pos) = next_token false cstrm in
      begin match glex.tok_comm with
        Some list ->
          if fst loc > comm_bp then
            let comm_loc = Stdpp.make_loc (comm_bp, fst loc) in
            glex.tok_comm <- Some (comm_loc :: list)
      | None -> ()
      end;
      r, make_lined_loc t_line_nb t_bol_pos loc
    with
      Stream.Error str -> err (Stream.count cstrm, Stream.count cstrm + 1) str
;;

let dollar_for_antiquotation = ref true;;
let specific_space_dot = ref false;;

let func kwd_table glexr =
  let find = Hashtbl.find kwd_table in
  let dfa = !dollar_for_antiquotation in
  let ssd = !specific_space_dot in
  Token.lexer_func_of_parser (next_token_fun dfa ssd find glexr)
;;

let rec check_keyword_stream (strm__ : _ Stream.t) =
  let _ = check strm__ in
  let _ =
    try Stream.empty strm__ with
      Stream.Failure -> raise (Stream.Error "")
  in
  true
and check (strm__ : _ Stream.t) =
  match Stream.peek strm__ with
    Some
      ('A'..'Z' | 'a'..'z' | '\192'..'\214' | '\216'..'\246' |
       '\248'..'\255') ->
      Stream.junk strm__; check_ident strm__
  | Some
      ('!' | '?' | '~' | '=' | '@' | '^' | '&' | '+' | '-' | '*' | '/' | '%' |
       '.') ->
      Stream.junk strm__; check_ident2 strm__
  | Some '<' ->
      Stream.junk strm__;
      let s = strm__ in
      begin match Stream.npeek 1 s with
        [':' | '<'] -> ()
      | _ -> check_ident2 s
      end
  | Some ':' ->
      Stream.junk strm__;
      let _ =
        try
          match Stream.peek strm__ with
            Some (']' | ':' | '=' | '>') -> Stream.junk strm__; ()
          | _ -> ()
        with
          Stream.Failure -> raise (Stream.Error "")
      in
      ()
  | Some ('>' | '|') ->
      Stream.junk strm__;
      let _ =
        try
          match Stream.peek strm__ with
            Some (']' | '}') -> Stream.junk strm__; ()
          | _ -> check_ident2 strm__
        with
          Stream.Failure -> raise (Stream.Error "")
      in
      ()
  | Some ('[' | '{') ->
      Stream.junk strm__;
      let s = strm__ in
      begin match Stream.npeek 2 s with
        ['<'; '<' | ':'] -> ()
      | _ ->
          let (strm__ : _ Stream.t) = s in
          match Stream.peek strm__ with
            Some ('|' | '<' | ':') -> Stream.junk strm__; ()
          | _ -> ()
      end
  | Some ';' ->
      Stream.junk strm__;
      let _ =
        try
          match Stream.peek strm__ with
            Some ';' -> Stream.junk strm__; ()
          | _ -> ()
        with
          Stream.Failure -> raise (Stream.Error "")
      in
      ()
  | Some _ -> Stream.junk strm__; ()
  | _ -> raise Stream.Failure
and check_ident (strm__ : _ Stream.t) =
  match Stream.peek strm__ with
    Some
      ('A'..'Z' | 'a'..'z' | '\192'..'\214' | '\216'..'\246' |
       '\248'..'\255' | '0'..'9' | '_' | '\'') ->
      Stream.junk strm__; check_ident strm__
  | _ -> ()
and check_ident2 (strm__ : _ Stream.t) =
  match Stream.peek strm__ with
    Some
      ('!' | '?' | '~' | '=' | '@' | '^' | '&' | '+' | '-' | '*' | '/' | '%' |
       '.' | ':' | '<' | '>' | '|') ->
      Stream.junk strm__; check_ident2 strm__
  | _ -> ()
;;

let check_keyword s =
  try check_keyword_stream (Stream.of_string s) with
    _ -> false
;;

let error_no_respect_rules p_con p_prm =
  raise
    (Token.Error
       ("the token " ^
          (if p_con = "" then "\"" ^ p_prm ^ "\""
           else if p_prm = "" then p_con
           else p_con ^ " \"" ^ p_prm ^ "\"") ^
          " does not respect Plexer rules"))
;;

let error_ident_and_keyword p_con p_prm =
  raise
    (Token.Error
       ("the token \"" ^ p_prm ^ "\" is used as " ^ p_con ^
          " and as keyword"))
;;

let using_token kwd_table ident_table (p_con, p_prm) =
  match p_con with
    "" ->
      if not (Hashtbl.mem kwd_table p_prm) then
        if check_keyword p_prm then
          if Hashtbl.mem ident_table p_prm then
            error_ident_and_keyword (Hashtbl.find ident_table p_prm) p_prm
          else Hashtbl.add kwd_table p_prm p_prm
        else error_no_respect_rules p_con p_prm
  | "LIDENT" ->
      if p_prm = "" then ()
      else
        begin match p_prm.[0] with
          'A'..'Z' -> error_no_respect_rules p_con p_prm
        | _ ->
            if Hashtbl.mem kwd_table p_prm then
              error_ident_and_keyword p_con p_prm
            else Hashtbl.add ident_table p_prm p_con
        end
  | "UIDENT" ->
      if p_prm = "" then ()
      else
        begin match p_prm.[0] with
          'a'..'z' -> error_no_respect_rules p_con p_prm
        | _ ->
            if Hashtbl.mem kwd_table p_prm then
              error_ident_and_keyword p_con p_prm
            else Hashtbl.add ident_table p_prm p_con
        end
  | "TILDEIDENT" | "QUESTIONIDENT" | "INT" | "INT_l" | "INT_L" | "INT_n" |
    "FLOAT" | "CHAR" | "STRING" | "QUOTATION" | "ANTIQUOT" | "LOCATE" |
    "EOI" ->
      ()
  | _ ->
      raise
        (Token.Error
           ("the constructor \"" ^ p_con ^ "\" is not recognized by Plexer"))
;;

let removing_token kwd_table ident_table (p_con, p_prm) =
  match p_con with
    "" -> Hashtbl.remove kwd_table p_prm
  | "LIDENT" | "UIDENT" ->
      if p_prm <> "" then Hashtbl.remove ident_table p_prm
  | _ -> ()
;;

let text =
  function
    "", t -> "'" ^ t ^ "'"
  | "LIDENT", "" -> "lowercase identifier"
  | "LIDENT", t -> "'" ^ t ^ "'"
  | "UIDENT", "" -> "uppercase identifier"
  | "UIDENT", t -> "'" ^ t ^ "'"
  | "INT", "" -> "integer"
  | "INT", s -> "'" ^ s ^ "'"
  | "FLOAT", "" -> "float"
  | "STRING", "" -> "string"
  | "CHAR", "" -> "char"
  | "QUOTATION", "" -> "quotation"
  | "ANTIQUOT", k -> "antiquot \"" ^ k ^ "\""
  | "LOCATE", "" -> "locate"
  | "EOI", "" -> "end of input"
  | con, "" -> con
  | con, prm -> con ^ " \"" ^ prm ^ "\""
;;

let eq_before_colon p e =
  let rec loop i =
    if i == String.length e then
      failwith "Internal error in Plexer: incorrect ANTIQUOT"
    else if i == String.length p then e.[i] == ':'
    else if p.[i] == e.[i] then loop (i + 1)
    else false
  in
  loop 0
;;

let after_colon e =
  try
    let i = String.index e ':' in
    String.sub e (i + 1) (String.length e - i - 1)
  with
    Not_found -> ""
;;

let tok_match =
  function
    "ANTIQUOT", p_prm ->
      begin function
        "ANTIQUOT", prm when eq_before_colon p_prm prm -> after_colon prm
      | _ -> raise Stream.Failure
      end
  | tok -> Token.default_match tok
;;

let gmake () =
  let kwd_table = Hashtbl.create 301 in
  let id_table = Hashtbl.create 301 in
  let glexr =
    ref
      {tok_func = (fun _ -> raise (Match_failure ("plexer.ml", 663, 17)));
       tok_using = (fun _ -> raise (Match_failure ("plexer.ml", 663, 37)));
       tok_removing = (fun _ -> raise (Match_failure ("plexer.ml", 663, 60)));
       tok_match = (fun _ -> raise (Match_failure ("plexer.ml", 664, 18)));
       tok_text = (fun _ -> raise (Match_failure ("plexer.ml", 664, 37)));
       tok_comm = None}
  in
  let glex =
    {tok_func = func kwd_table glexr;
     tok_using = using_token kwd_table id_table;
     tok_removing = removing_token kwd_table id_table; tok_match = tok_match;
     tok_text = text; tok_comm = None}
  in
  glexr := glex; glex
;;
